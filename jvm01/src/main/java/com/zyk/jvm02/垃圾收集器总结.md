## 垃圾收集器总结

### Serial GC

串行GC对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-
清除-整理） 算法。
两者都是单线程的垃圾收集器，不能进行并行处理，所以都会触发全线暂停（STW），停止所有的应用线程。

对于服务器端来说，因为一般是多个CPU内核，并不推荐使用，除非确实需要限制JVM所使用的资源。大多数服务器端应用部署在多核平台上，选择 串行 GC 就意味着人为地限制了系统资源的使用，会导致资源闲置，多余的CPU资源也不能用增加业务处理的吞吐量。

## Parallel GC

并行垃圾收集器对年轻代使用 标记-复制(mark-copy) 算法，对老年代使用 标记-清除-整理(mark-sweep-compact) 算法。年轻代和老年代的垃圾回收时都会触发STW事件，暂停所有的应用线程，再来执行垃圾收集。在执行 标记和 复制/整理 阶段时都使用多个线程，因此得名“ Parallel ”。通过多个GC线程并行执行的方式，能使JVM在多CPU平台上的GC时间大幅减少。

并行垃圾收集器适用于多核服务器，其主要目标是增加系统吞吐量(也就是降低GC总体消耗的时间)。为了达成这个目标，会尽量使用尽可能多的CPU资源：
在GC事件执行期间，所有 CPU 内核都在并行地清理垃圾，所以暂停时间相对来说更短
在两次GC事件中间的间隔期，不会启动GC线程，所以这段时间内不会消耗任何系统资源
另一方面，因为并行GC的所有阶段都不能中断，所以并行GC很可能会出现长时间的卡顿。长时间卡顿的意思，就是并行GC启动后，一次性完成所有的GC操作，所以单次暂停的时间较长。假如系统延迟是非常重要
的性能指标，那么就应该选择其他垃圾收集器。

## CMS GC

CMS垃圾收集器在减少停顿时间上做了很多给力的工作，很大一部分GC线程是与应用线程并发运行
的，不需要暂停应用线程，这样就可以在一般情况下每次暂停的时候较少。当然，CMS也有一些缺点，其中最大的问题就是老年代的内存碎片问题，在某些情况下GC会有不可预测的暂停时间，特别是堆内存较大的情况下



## G1 GC

为了达成可预期停顿时间的指标，G1 GC有一些独特的实现。
首先，堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的 小块堆区域
(smaller heap regions) 。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor区或者Old
区。在逻辑上，所有的Eden区和Survivor区合起来就是年轻代，所有的Old区拼在一起那就是老年代。

